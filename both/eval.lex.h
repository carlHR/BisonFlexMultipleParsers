#ifndef evalHEADER_H
#define evalHEADER_H 1
#define evalIN_HEADER 1

#line 5 "C:\\Users\\carlo\\Documents\\Escritorio\\BisonFlexMultipleParsers\\both\\eval.lex.h"

#line 7 "C:\\Users\\carlo\\Documents\\Escritorio\\BisonFlexMultipleParsers\\both\\eval.lex.h"

#define  EVAL_INT_ALIGNED short int

/* A lexical scanner generated by flex */

#define FLEX_SCANNER
#define EVAL_FLEX_MAJOR_VERSION 2
#define EVAL_FLEX_MINOR_VERSION 6
#define EVAL_FLEX_SUBMINOR_VERSION 4
#if EVAL_FLEX_SUBMINOR_VERSION > 0
#define FLEX_BETA
#endif

#ifdef evalget_lval
#define evalget_lval_ALREADY_DEFINED
#else
#define evalget_lval evalget_lval
#endif

#ifdef evalset_lval
#define evalset_lval_ALREADY_DEFINED
#else
#define evalset_lval evalset_lval
#endif

#ifdef evalget_lloc
#define evalget_lloc_ALREADY_DEFINED
#else
#define evalget_lloc evalget_lloc
#endif

#ifdef evalset_lloc
#define evalset_lloc_ALREADY_DEFINED
#else
#define evalset_lloc evalset_lloc
#endif

/* First, we deal with  platform-specific or compiler-specific issues. */

/* begin standard C headers. */
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <stdlib.h>

/* end standard C headers. */

/* flex integer type definitions */

#ifndef FLEXINT_H
#define FLEXINT_H

/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */

#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L

/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
 * if you want the limit (max/min) macros for int types. 
 */
#ifndef __STDC_LIMIT_MACROS
#define __STDC_LIMIT_MACROS 1
#endif

#include <inttypes.h>
typedef int8_t flex_int8_t;
typedef uint8_t flex_uint8_t;
typedef int16_t flex_int16_t;
typedef uint16_t flex_uint16_t;
typedef int32_t flex_int32_t;
typedef uint32_t flex_uint32_t;
#else
typedef signed char flex_int8_t;
typedef short int flex_int16_t;
typedef int flex_int32_t;
typedef unsigned char flex_uint8_t; 
typedef unsigned short int flex_uint16_t;
typedef unsigned int flex_uint32_t;

/* Limits of integral types. */
#ifndef INT8_MIN
#define INT8_MIN               (-128)
#endif
#ifndef INT16_MIN
#define INT16_MIN              (-32767-1)
#endif
#ifndef INT32_MIN
#define INT32_MIN              (-2147483647-1)
#endif
#ifndef INT8_MAX
#define INT8_MAX               (127)
#endif
#ifndef INT16_MAX
#define INT16_MAX              (32767)
#endif
#ifndef INT32_MAX
#define INT32_MAX              (2147483647)
#endif
#ifndef UINT8_MAX
#define UINT8_MAX              (255U)
#endif
#ifndef UINT16_MAX
#define UINT16_MAX             (65535U)
#endif
#ifndef UINT32_MAX
#define UINT32_MAX             (4294967295U)
#endif

#ifndef SIZE_MAX
#define SIZE_MAX               (~(size_t)0)
#endif

#endif /* ! C99 */

#endif /* ! FLEXINT_H */

/* begin standard C++ headers. */

/* TODO: this is always defined, so inline it */
#define evalconst const

#if defined(__GNUC__) && __GNUC__ >= 3
#define evalnoreturn __attribute__((__noreturn__))
#else
#define evalnoreturn
#endif

/* An opaque pointer. */
#ifndef EVAL_TYPEDEF_EVAL_SCANNER_T
#define EVAL_TYPEDEF_EVAL_SCANNER_T
typedef void* evalscan_t;
#endif

/* For convenience, these vars (plus the bison vars far below)
   are macros in the reentrant scanner. */
#define evalin evalg->evalin_r
#define evalout evalg->evalout_r
#define evalextra evalg->evalextra_r
#define evalleng evalg->evalleng_r
#define evaltext evalg->evaltext_r
#define evallineno (EVAL_CURRENT_BUFFER_LVALUE->eval_bs_lineno)
#define evalcolumn (EVAL_CURRENT_BUFFER_LVALUE->eval_bs_column)
#define eval_flex_debug evalg->eval_flex_debug_r

/* Size of default input buffer. */
#ifndef EVAL_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k.
 * Moreover, EVAL_BUF_SIZE is 2*EVAL_READ_BUF_SIZE in the general case.
 * Ditto for the __ia64__ case accordingly.
 */
#define EVAL_BUF_SIZE 32768
#else
#define EVAL_BUF_SIZE 16384
#endif /* __ia64__ */
#endif

#ifndef EVAL_TYPEDEF_EVAL_BUFFER_STATE
#define EVAL_TYPEDEF_EVAL_BUFFER_STATE
typedef struct eval_buffer_state *EVAL_BUFFER_STATE;
#endif

#ifndef EVAL_TYPEDEF_EVAL_SIZE_T
#define EVAL_TYPEDEF_EVAL_SIZE_T
typedef size_t eval_size_t;
#endif

#ifndef EVAL_STRUCT_EVAL_BUFFER_STATE
#define EVAL_STRUCT_EVAL_BUFFER_STATE
struct eval_buffer_state
	{
	FILE *eval_input_file;

	char *eval_ch_buf;		/* input buffer */
	char *eval_buf_pos;		/* current position in input buffer */

	/* Size of input buffer in bytes, not including room for EOB
	 * characters.
	 */
	int eval_buf_size;

	/* Number of characters read into eval_ch_buf, not including EOB
	 * characters.
	 */
	int eval_n_chars;

	/* Whether we "own" the buffer - i.e., we know we created it,
	 * and can realloc() it to grow it, and should free() it to
	 * delete it.
	 */
	int eval_is_our_buffer;

	/* Whether this is an "interactive" input source; if so, and
	 * if we're using stdio for input, then we want to use getc()
	 * instead of fread(), to make sure we stop fetching input after
	 * each newline.
	 */
	int eval_is_interactive;

	/* Whether we're considered to be at the beginning of a line.
	 * If so, '^' rules will be active on the next match, otherwise
	 * not.
	 */
	int eval_at_bol;

    int eval_bs_lineno; /**< The line count. */
    int eval_bs_column; /**< The column count. */

	/* Whether to try to fill the input buffer when we reach the
	 * end of it.
	 */
	int eval_fill_buffer;

	int eval_buffer_status;

	};
#endif /* !EVAL_STRUCT_EVAL_BUFFER_STATE */

void evalrestart ( FILE *input_file , evalscan_t evalscanner );
void eval_switch_to_buffer ( EVAL_BUFFER_STATE new_buffer , evalscan_t evalscanner );
EVAL_BUFFER_STATE eval_create_buffer ( FILE *file, int size , evalscan_t evalscanner );
void eval_delete_buffer ( EVAL_BUFFER_STATE b , evalscan_t evalscanner );
void eval_flush_buffer ( EVAL_BUFFER_STATE b , evalscan_t evalscanner );
void evalpush_buffer_state ( EVAL_BUFFER_STATE new_buffer , evalscan_t evalscanner );
void evalpop_buffer_state ( evalscan_t evalscanner );

EVAL_BUFFER_STATE eval_scan_buffer ( char *base, eval_size_t size , evalscan_t evalscanner );
EVAL_BUFFER_STATE eval_scan_string ( const char *eval_str , evalscan_t evalscanner );
EVAL_BUFFER_STATE eval_scan_bytes ( const char *bytes, int len , evalscan_t evalscanner );

void *evalalloc ( eval_size_t , evalscan_t evalscanner );
void *evalrealloc ( void *, eval_size_t , evalscan_t evalscanner );
void evalfree ( void * , evalscan_t evalscanner );

#define evalwrap(evalscanner) (/*CONSTCOND*/1)
#define EVAL_SKIP_EVALWRAP

#define evaltext_ptr evaltext_r

#ifdef EVAL_HEADER_EXPORT_START_CONDITIONS
#define INITIAL 0

#endif

#ifndef EVAL_NO_UNISTD_H
/* Special case for "unistd.h", since it is non-ANSI. We include it way
 * down here because we want the user's section 1 to have been scanned first.
 * The user has a chance to override it with an option.
 */
#include <unistd.h>
#endif

#ifndef EVAL_EXTRA_TYPE
#define EVAL_EXTRA_TYPE void *
#endif

int evallex_init (evalscan_t* scanner);

int evallex_init_extra ( EVAL_EXTRA_TYPE user_defined, evalscan_t* scanner);

/* Accessor methods to globals.
   These are made visible to non-reentrant scanners for convenience. */

int evallex_destroy ( evalscan_t evalscanner );

int evalget_debug ( evalscan_t evalscanner );

void evalset_debug ( int debug_flag , evalscan_t evalscanner );

EVAL_EXTRA_TYPE evalget_extra ( evalscan_t evalscanner );

void evalset_extra ( EVAL_EXTRA_TYPE user_defined , evalscan_t evalscanner );

FILE *evalget_in ( evalscan_t evalscanner );

void evalset_in  ( FILE * _in_str , evalscan_t evalscanner );

FILE *evalget_out ( evalscan_t evalscanner );

void evalset_out  ( FILE * _out_str , evalscan_t evalscanner );

			int evalget_leng ( evalscan_t evalscanner );

char *evalget_text ( evalscan_t evalscanner );

int evalget_lineno ( evalscan_t evalscanner );

void evalset_lineno ( int _line_number , evalscan_t evalscanner );

int evalget_column  ( evalscan_t evalscanner );

void evalset_column ( int _column_no , evalscan_t evalscanner );

EVALSTYPE * evalget_lval ( evalscan_t evalscanner );

void evalset_lval ( EVALSTYPE * evallval_param , evalscan_t evalscanner );

       EVALLTYPE *evalget_lloc ( evalscan_t evalscanner );
    
        void evalset_lloc ( EVALLTYPE * evallloc_param , evalscan_t evalscanner );
    
/* Macros after this point can all be overridden by user definitions in
 * section 1.
 */

#ifndef EVAL_SKIP_EVALWRAP
#ifdef __cplusplus
extern "C" int evalwrap ( evalscan_t evalscanner );
#else
extern int evalwrap ( evalscan_t evalscanner );
#endif
#endif

#ifndef evaltext_ptr
static void eval_flex_strncpy ( char *, const char *, int , evalscan_t evalscanner);
#endif

#ifdef EVAL_NEED_STRLEN
static int eval_flex_strlen ( const char * , evalscan_t evalscanner);
#endif

#ifndef EVAL_NO_INPUT

#endif

/* Amount of stuff to slurp up with each read. */
#ifndef EVAL_READ_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k */
#define EVAL_READ_BUF_SIZE 16384
#else
#define EVAL_READ_BUF_SIZE 8192
#endif /* __ia64__ */
#endif

/* Number of entries by which start-condition stack grows. */
#ifndef EVAL_START_STACK_INCR
#define EVAL_START_STACK_INCR 25
#endif

/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */
#ifndef EVAL_DECL
#define EVAL_DECL_IS_OURS 1

extern int evallex \
               (EVALSTYPE * evallval_param, EVALLTYPE * evallloc_param , evalscan_t evalscanner);

#define EVAL_DECL int evallex \
               (EVALSTYPE * evallval_param, EVALLTYPE * evallloc_param , evalscan_t evalscanner)
#endif /* !EVAL_DECL */

/* eval_get_previous_state - get the state just before the EOB char was reached */

#undef EVAL_NEW_FILE
#undef EVAL_FLUSH_BUFFER
#undef eval_set_bol
#undef eval_new_buffer
#undef eval_set_interactive
#undef EVAL_DO_BEFORE_ACTION

#ifdef EVAL_DECL_IS_OURS
#undef EVAL_DECL_IS_OURS
#undef EVAL_DECL
#endif

#ifndef eval_create_buffer_ALREADY_DEFINED
#undef eval_create_buffer
#endif
#ifndef eval_delete_buffer_ALREADY_DEFINED
#undef eval_delete_buffer
#endif
#ifndef eval_scan_buffer_ALREADY_DEFINED
#undef eval_scan_buffer
#endif
#ifndef eval_scan_string_ALREADY_DEFINED
#undef eval_scan_string
#endif
#ifndef eval_scan_bytes_ALREADY_DEFINED
#undef eval_scan_bytes
#endif
#ifndef eval_init_buffer_ALREADY_DEFINED
#undef eval_init_buffer
#endif
#ifndef eval_flush_buffer_ALREADY_DEFINED
#undef eval_flush_buffer
#endif
#ifndef eval_load_buffer_state_ALREADY_DEFINED
#undef eval_load_buffer_state
#endif
#ifndef eval_switch_to_buffer_ALREADY_DEFINED
#undef eval_switch_to_buffer
#endif
#ifndef evalpush_buffer_state_ALREADY_DEFINED
#undef evalpush_buffer_state
#endif
#ifndef evalpop_buffer_state_ALREADY_DEFINED
#undef evalpop_buffer_state
#endif
#ifndef evalensure_buffer_stack_ALREADY_DEFINED
#undef evalensure_buffer_stack
#endif
#ifndef evallex_ALREADY_DEFINED
#undef evallex
#endif
#ifndef evalrestart_ALREADY_DEFINED
#undef evalrestart
#endif
#ifndef evallex_init_ALREADY_DEFINED
#undef evallex_init
#endif
#ifndef evallex_init_extra_ALREADY_DEFINED
#undef evallex_init_extra
#endif
#ifndef evallex_destroy_ALREADY_DEFINED
#undef evallex_destroy
#endif
#ifndef evalget_debug_ALREADY_DEFINED
#undef evalget_debug
#endif
#ifndef evalset_debug_ALREADY_DEFINED
#undef evalset_debug
#endif
#ifndef evalget_extra_ALREADY_DEFINED
#undef evalget_extra
#endif
#ifndef evalset_extra_ALREADY_DEFINED
#undef evalset_extra
#endif
#ifndef evalget_in_ALREADY_DEFINED
#undef evalget_in
#endif
#ifndef evalset_in_ALREADY_DEFINED
#undef evalset_in
#endif
#ifndef evalget_out_ALREADY_DEFINED
#undef evalget_out
#endif
#ifndef evalset_out_ALREADY_DEFINED
#undef evalset_out
#endif
#ifndef evalget_leng_ALREADY_DEFINED
#undef evalget_leng
#endif
#ifndef evalget_text_ALREADY_DEFINED
#undef evalget_text
#endif
#ifndef evalget_lineno_ALREADY_DEFINED
#undef evalget_lineno
#endif
#ifndef evalset_lineno_ALREADY_DEFINED
#undef evalset_lineno
#endif
#ifndef evalget_column_ALREADY_DEFINED
#undef evalget_column
#endif
#ifndef evalset_column_ALREADY_DEFINED
#undef evalset_column
#endif
#ifndef evalwrap_ALREADY_DEFINED
#undef evalwrap
#endif
#ifndef evalget_lval_ALREADY_DEFINED
#undef evalget_lval
#endif
#ifndef evalset_lval_ALREADY_DEFINED
#undef evalset_lval
#endif
#ifndef evalget_lloc_ALREADY_DEFINED
#undef evalget_lloc
#endif
#ifndef evalset_lloc_ALREADY_DEFINED
#undef evalset_lloc
#endif
#ifndef evalalloc_ALREADY_DEFINED
#undef evalalloc
#endif
#ifndef evalrealloc_ALREADY_DEFINED
#undef evalrealloc
#endif
#ifndef evalfree_ALREADY_DEFINED
#undef evalfree
#endif
#ifndef evaltext_ALREADY_DEFINED
#undef evaltext
#endif
#ifndef evalleng_ALREADY_DEFINED
#undef evalleng
#endif
#ifndef evalin_ALREADY_DEFINED
#undef evalin
#endif
#ifndef evalout_ALREADY_DEFINED
#undef evalout
#endif
#ifndef eval_flex_debug_ALREADY_DEFINED
#undef eval_flex_debug
#endif
#ifndef evallineno_ALREADY_DEFINED
#undef evallineno
#endif
#ifndef evaltables_fload_ALREADY_DEFINED
#undef evaltables_fload
#endif
#ifndef evaltables_destroy_ALREADY_DEFINED
#undef evaltables_destroy
#endif
#ifndef evalTABLES_NAME_ALREADY_DEFINED
#undef evalTABLES_NAME
#endif

#line 27 "../eval/eval.l"

#line 521 "C:\\Users\\carlo\\Documents\\Escritorio\\BisonFlexMultipleParsers\\both\\eval.lex.h"
#undef evalIN_HEADER
#endif /* evalHEADER_H */
